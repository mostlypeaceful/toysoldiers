#ifndef __tTouch__
#define __tTouch__
#include "tRingBuffer.hpp"
#include "tFixedBitArray.hpp"

namespace Sig { namespace Input
{

	///
	/// \brief Facilitates a single user's touch interface.
	class base_export tTouch
	{
		class tPlatformInternal;
	public:
		enum tFinger
		{
			cFinger1,
			cFinger2,
			cFingerCount = 16,

			// Psuedo-fingers
			cFingerAny,
			cFingerNone,
			
			// Finger categories
			cFingersAll,
			cFingersDragging,
			cFingersNone = cFingerNone,
		};

		enum tStateFlag
		{
			cFlagFingerDownEvent,		///< A raw "down" event
			cFlagFingerUpEvent,			///< A raw "up" event
			cFlagFingerTapEvent,		///< Event generated by an "up" event, if the finger has traveled less than Input_Tweak_DragThreshold.  Use for UI interaction.
			cFlagFingerDoubleTapEvent,	///< Event generated by a second up even within a time threshold.  Implies cFlagFingerTapEvent as well.

			cFlagFingerHeld,			///< Set on a down event, unset on up.

			cFlagFingerDragging,		///< Set if the finger has traveled more than Input_Tweak_DragThreshold, cleared on FingerUpEvent
		};

		typedef Math::tVec2f	tPosition;
		typedef u32				tHwFingerId;

		// one of these per touch instance.
		struct tTouchStateData
		{

			tPosition		mPosition;
			tHwFingerId		mHwFingerId;
			tFlags16		mFlags;
			u16				pad;

			tTouchStateData( )
				: mPosition( tPosition::cZeroVector )
				, mHwFingerId( 0 )
				, mFlags( 0 )
			{ }
		};

		struct tTouchInstanceData
		{
			tPosition mDragStart;
			tPosition mDragCurrent;

			tTouchInstanceData( )
				: mDragStart( tPosition::cZeroVector )
				, mDragCurrent( tPosition::cZeroVector )
			{ }
		};

		typedef tFixedArray< tTouchStateData, cFingerCount > tStateData;
		typedef tRingBuffer< tStateData > tStateDataBuffer;
		typedef void* tGenericWindowHandle;

	private:

		tFixedArray< tTouchInstanceData, cFingerCount > mInstanceData;
		tStateDataBuffer		mStateHistory;
		tStateData				mRawState; // updated in response to WM_TOUCH and it's kin, with event flags clearing on fCaptureState
		tGenericWindowHandle	mWindowHandle;

	public:
		static const tTouch cNullTouch;

	public:

		tTouch( );
		~tTouch( );

		///
		/// \brief Should be called to initialize all touch input, registers the device with the system callbacks.
		void fStartup( tGenericWindowHandle winHandle );

		///
		/// \brief Should be called once for each call to fStartup to uninitialize all touch input.
		void fShutdown( );

		///
		/// \brief Capture the current state of the input and add it to the history buffer.
		/// \note This should be called once per frame.
		void fCaptureState( f32 dt = 1.f );

		///
		/// \brief Capture the current state of the mouse and put it in the output variable,
		/// without putting it in the history buffer. Prefer getting the state history and
		/// accessing the fFront( ) item.
		void fCaptureStateUnbuffered( tStateData& stateData, f32 dt = 1.f );

		///
		/// \brief Set new size of the history buffer. This method will clamp the input
		/// size to a minimum of 2. The mouse starts by default with a history size of two.
		void fSetHistorySize( u32 newSize );

		///
		/// \brief Access the state history buffer.
		const tStateDataBuffer& fGetStateHistory( ) const;

		///
		/// \brief Access the last state in the history buffer.
		const tStateData& fGetState( ) const;

		///
		/// \brief Query for whether our touch data has changed.
		b32 fUpdated( ) const;

		/// \brief Query for whether our touch data has changed or fingers are down
		b32 fActive( ) const;

		///
		/// \brief Query for the number of fingers currently held down (tests latest frame only).
		u32 fCountFingersHeld( ) const;

		///
		/// \brief Query for whether the specified finger is currently held down (tests latest frame only).
		b32 fFingerHeld( tFinger finger ) const;

		///
		/// \brief Query for whether the specified finger is flagged as "dragging".
		b32 fFingerDragging( tFinger finger ) const;

		///
		/// \brief Query for whether the specified finger has just been "tapped" (i.e. released and not dragged) (between this frame and last).
		b32 fFingerTapped( tFinger finger ) const;

		///
		/// \brief Query for whether the specified finger has just been "double tapped" (i.e. released and not dragged, twice, within a threshhold)
		b32 fFingerDoubleTapped( tFinger finger ) const;

		///
		/// \brief Query for whether the specified finger has just been pressed (between this frame and last).
		b32 fFingerDown( tFinger finger ) const;

		///
		/// \brief Query for whether the specified finger has just been let go (between this frame and last).
		b32 fFingerUp( tFinger finger ) const;


		/// \brief Fills an array with finger indicies with the given flag, fills the rest with cFingerNone, and returns how many of them actually matched.
		template < size_t N >
		u32 fGetFingersFlagged( tFixedArray<tFinger,N>& output, tStateFlag flag ) const
		{
			u32 n=0;
			for ( int i=0 ; i<cFingerCount && n<N ; ++i )
			{
				if ( fGetState( )[i].mFlags.fGetBit(flag) )
					output[n++] = (tFinger)i;
			}

			for ( int i=n ; i<N ; ++i )
				output[i] = cFingerNone;

			return n;
		}

		/// \brief Get the first finger that's just been tapped (if any, otherwise cFingerNone)
		tFinger fFirstTappedFinger( ) const;

		/// \brief Query for whether the specified finger has just been "double tapped" (i.e. released and not dragged, twice, within a threshhold)
		tFinger fFirstDoubleTappedFinger( ) const;

		/// \brief Get the first finger that's currently held down (if any, otherwise cFingerNone)
		tFinger fFirstHeldFinger( ) const;

		/// \brief Get the first finger that has just been pressed (if any, otherwise cFingerNone)
		tFinger fFirstDownFinger( ) const;

		/// \brief Get the first finger that has just been release (if any, otherwise cFingerNone)
		tFinger fFirstUpFinger( ) const;

		/// \brief Query for whether the specified finger is within the area
		b32 fFingerWithin( tFinger finger, const Math::tRectf& area ) const;

		/// \brief Return the finger position (cFingerAny not accepted)
		tPosition fFingerPosition( tFinger finger ) const;

		/// \brief If not held, return 0.  Otherwise, return the finger position (first held if cFingerAny and multiple held).
		tPosition fHeldFingerPosition( tFinger finger ) const;

		/// \brief If a finger is held (or just released), this will give you the displacement relative from where it initially touched.
		///    Will also accept cFingersNone, cFingersDragging, and cFingersAll -- in which case it will return the *average* relative drag.
		///    Returns zero if no fingers were held nor just released, or if finger was cFinger[s]None
		Math::tVec2f fFingerDragTotal( tFinger finger ) const;

		/// \brief If a finger is held (or just released), this will give you the displacement between this finger's position, and where it was last frame.
		///    Will also accept cFingersNone, cFingersDragging, and cFingersAll -- in which case it will return the *average* absolute drag.
		///    Returns zero if no fingers were held nor just released, or if finger was cFinger[s]None
		Math::tVec2f fFingerDragThisFrame( tFinger finger ) const;

		/// \brief This slot can be reused for a new finger at this point.
		static b32 fCanReuseSlot( const tTouchStateData& slot );

#if defined( platform_pcdx )
		static void fTouchWndProc( HWND hwnd, WPARAM wParam, LPARAM lParam );
#endif
	private:
		///
		/// \brief Checks if a finger flag is set, properly handling finger==cFingerAny
		b32 fCheckFingerFlag( const tStateData& data, tFinger finger, u32 bitNum ) const;

		///
		/// \brief Clears all cFlagFinger*Event flags, and possibly cFlagFingerDragging.
		static void fClearEventFlags( tStateData& data );

		void fHandleRawDown( tTouch::tFinger finger, Math::tVec2f position );

		void fHandleRawUp( tTouch::tFinger finger, Math::tVec2f position );

		b32 fRecoverBadFingers( tHwFingerId hwFinger, const Math::tVec2f& fingerPos );

		/// \brief Check mStateHistory for tap events within a given age (in history frames) and distance (in pixels in renderspace)
		b32 fPreviousTapNear( const Math::tVec2f& fingerPos, u32 maxAge, f32 maxDist );

		/// \brief Called once per frame
		void fStepDrag( f32 dt );
	};
}}


#endif//__tTouch__
